# sci-math-wasm Development Roadmap ðŸš€

> **Vision:** Transform sci-math-wasm into the definitive scientific computing library for the web platform, combining the raw power of Rust/WebAssembly with exceptional developer experience.

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Phase 1: Foundation & DX](#phase-1-foundation--dx-q1-2026)
3. [Phase 2: Performance & Features](#phase-2-performance--features-q2-2026)
4. [Phase 3: Ecosystem & Integrations](#phase-3-ecosystem--integrations-q3-2026)
5. [Phase 4: Advanced Features](#phase-4-advanced-features-q4-2026)
6. [Technical Debt & Improvements](#technical-debt--improvements)
7. [Architecture Decisions](#architecture-decisions)

---

## Executive Summary

### Current State Analysis

**Strengths:**
- Solid mathematical foundation (stats, linalg, signal, fitting, analysis)
- Parallel processing with Rayon (multi-threaded WASM)
- Flexible file I/O (CSV, Excel, scientific formats)
- Pure JS fallback via `SciMathJS` with WASM delegation
- Good performance for heavy computations (FFT, MatMul)

**Areas for Improvement:**
- Initialization flow is cumbersome (manual `init()` + `initThreadPool()`)
- TypeScript types could be more ergonomic
- No framework-specific integrations (React hooks, Vue composables)
- Missing higher-level abstractions (DataFrame-like structures)
- Limited error handling and debugging tools
- No CDN/UMD distribution for quick prototyping

---

## Phase 1: Foundation & DX (Q1 2026)

### 1.1 Zero-Config Initialization âš¡

**Problem:** Users must manually call `init()` and `initThreadPool()` before using the library.

**Solution:** Auto-initialization with lazy loading.

```typescript
// BEFORE (Current)
import init, { mean, initThreadPool } from 'sci-math-wasm';
await init();
await initThreadPool(navigator.hardwareConcurrency);
const avg = mean(data);

// AFTER (Proposed)
import { mean } from 'sci-math-wasm';
const avg = await mean(data); // Auto-initializes on first call
```

**Implementation:**
- [ ] Create `AutoInit` wrapper that lazily initializes WASM
- [ ] Detect `SharedArrayBuffer` support and auto-configure threads
- [ ] Provide `configure()` API for advanced users
- [ ] Add synchronous initialization option for Node.js

```typescript
// Advanced configuration (optional)
import { configure, mean } from 'sci-math-wasm';

configure({
  threads: 'auto',           // 'auto' | number | 'off'
  simd: true,                // Enable SIMD if available
  memoryPoolSize: '64mb',    // Pre-allocate memory pool
  onError: (err) => { ... }  // Global error handler
});
```

### 1.2 TypeScript Ergonomics

**Problem:** Current types are generated by wasm-bindgen and lack ergonomic patterns.

**Improvements:**
- [ ] Generic typed arrays support (`TypedData<T>`)
- [ ] Overloaded function signatures
- [ ] Better error types with discriminated unions
- [ ] JSDoc with LaTeX in IDE tooltips

```typescript
// Proposed type improvements
type NumericArray = Float64Array | Float32Array | number[];

interface SciMathResult<T> {
  data: T;
  metadata?: {
    executionTime: number;
    parallelized: boolean;
    memoryUsed: number;
  };
}

// Better error handling
type MathError = 
  | { code: 'DIMENSION_MISMATCH'; expected: number; received: number }
  | { code: 'SINGULAR_MATRIX'; condition: number }
  | { code: 'CONVERGENCE_FAILED'; iterations: number };
```

### 1.3 Debugging & Profiling Tools

- [ ] Add `debug` mode with detailed logging
- [ ] Performance profiler for identifying bottlenecks
- [ ] Memory usage tracker
- [ ] WASM vs JS execution path indicator

```typescript
import { enableDebug, getMetrics } from 'sci-math-wasm/debug';

enableDebug({
  logLevel: 'verbose',
  measurePerformance: true,
  trackMemory: true
});

const result = mean(data);
console.log(getMetrics()); 
// { lastOperation: 'mean', executionMs: 0.42, path: 'wasm', threads: 4 }
```

### 1.4 Error Handling Improvements

- [ ] Wrap all WASM panics in proper JS errors
- [ ] Add custom error classes with context
- [ ] Validation layer with helpful messages

```typescript
// Better error messages
try {
  matrixMultiply(a, 3, 4, b, 2, 3);
} catch (e) {
  // "Matrix multiplication failed: incompatible dimensions.
  //  Matrix A is 3Ã—4, Matrix B is 2Ã—3. 
  //  Expected B to have 4 rows to match A's columns."
}
```

---

## Phase 2: Performance & Features (Q2 2026)

### 2.1 SIMD Optimization

**Current:** Manual parallelization with Rayon only.
**Goal:** Add explicit SIMD paths using `core::arch::wasm32`.

- [ ] SIMD-accelerated dot product
- [ ] SIMD FFT butterfly operations
- [ ] SIMD matrix operations
- [ ] Feature detection and fallback

```rust
// Example SIMD optimization
#[cfg(target_feature = "simd128")]
pub fn dot_product_simd(a: &[f64], b: &[f64]) -> f64 {
    use core::arch::wasm32::*;
    // 2x f64 per SIMD register
    let chunks = a.len() / 2;
    let mut sum = f64x2_splat(0.0);
    
    for i in 0..chunks {
        let va = v128_load(a.as_ptr().add(i * 2) as *const v128);
        let vb = v128_load(b.as_ptr().add(i * 2) as *const v128);
        sum = f64x2_add(sum, f64x2_mul(va, vb));
    }
    // Horizontal sum + remainder
}
```

### 2.2 Memory Pool System

**Problem:** Frequent allocations cause GC pressure in JS.

**Solution:** Pre-allocated memory pools with zero-copy views.

- [ ] Implement `MemoryPool` class in Rust
- [ ] JS-side typed array views without copying
- [ ] Arena allocator for batch operations
- [ ] Automatic pool resizing

```typescript
// Zero-copy operations
import { createPool, withPool } from 'sci-math-wasm';

const pool = createPool({ size: '16mb' });

// Operations reuse pool memory
const result = await withPool(pool, async (ctx) => {
  const a = ctx.alloc(1000);
  const b = ctx.alloc(1000);
  const c = ctx.matmul(a, b, 32, 32, 32, 32); // No copy!
  return c.toArray(); // Copy only on exit
});
```

### 2.3 DataFrame API (High-Level Abstraction)

**Goal:** Pandas/Polars-like API for data manipulation.

```typescript
import { DataFrame } from 'sci-math-wasm';

const df = await DataFrame.fromCSV(file, { 
  inferTypes: true,
  skipRows: 2 
});

// Fluent API
const result = df
  .select(['time', 'voltage', 'current'])
  .filter(row => row.voltage > 0.5)
  .withColumn('power', (row) => row.voltage * row.current)
  .groupBy('time')
  .agg({
    voltage: 'mean',
    current: 'std',
    power: 'sum'
  })
  .sortBy('time');

// Export
await result.toCSV('output.csv');
const array = result.toFloat64Array('power');
```

### 2.4 Extended Mathematical Functions

**Statistics:**
- [ ] `percentile(data, p)` - Arbitrary percentile calculation
- [ ] `mode(data)` - Most frequent value
- [ ] `skewness(data)` - Asymmetry measure
- [ ] `kurtosis(data)` - Tail heaviness
- [ ] `covariance(x, y)` - Covariance matrix
- [ ] `correlation(x, y)` - Pearson correlation
- [ ] `histogram(data, bins)` - Binned frequency counts

**Linear Algebra:**
- [ ] `eigenvalues(matrix)` - Eigenvalue decomposition
- [ ] `svd(matrix)` - Singular Value Decomposition
- [ ] `lu(matrix)` - LU factorization
- [ ] `qr(matrix)` - QR decomposition
- [ ] `cholesky(matrix)` - Cholesky factorization
- [ ] `determinant(matrix)` - Matrix determinant
- [ ] `rank(matrix)` - Matrix rank
- [ ] `pseudoInverse(matrix)` - Moore-Penrose inverse

**Signal Processing:**
- [ ] `stft(data, window, hop)` - Short-Time Fourier Transform
- [ ] `istft(spectrum)` - Inverse STFT
- [ ] `spectrogram(data)` - Time-frequency representation
- [ ] `filter(data, kernel, type)` - FIR/IIR filters
- [ ] `resample(data, rate)` - Signal resampling
- [ ] `crossCorrelation(a, b)` - Cross-correlation
- [ ] `autoCorrelation(data)` - Auto-correlation
- [ ] `hilbert(data)` - Hilbert transform

**Calculus:**
- [ ] `gradient(f, x)` - Numerical gradient
- [ ] `hessian(f, x)` - Hessian matrix
- [ ] `ode45(f, y0, t)` - ODE solver (Runge-Kutta)
- [ ] `interpolate(x, y, method)` - Spline interpolation
- [ ] `roots(f, bracket)` - Root finding (Brent's method)

**Optimization:**
- [ ] `minimize(f, x0, method)` - Function minimization
- [ ] `leastSquares(A, b)` - Least squares solver
- [ ] `constrainedOptimize(f, constraints)` - Constrained optimization

---

## Phase 3: Ecosystem & Integrations (Q3 2026)

### 3.1 React Integration

```typescript
// @sci-math/react
import { useMath, useSciEngine, useDataFrame } from '@sci-math/react';

function SignalViewer({ data }) {
  const { result, loading, error } = useMath(
    () => fft(data),
    [data]
  );
  
  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;
  
  return <SpectrumChart data={result} />;
}

// With Suspense support
function Analysis() {
  const engine = useSciEngine();
  const spectrum = engine.fft(data); // Suspends until ready
  return <Chart data={spectrum} />;
}
```

### 3.2 Vue Integration

```typescript
// @sci-math/vue
import { useMath, useSciEngine } from '@sci-math/vue';

// Composition API
const { data, loading, error, execute } = useMath();

const result = computed(() => {
  if (!data.value) return null;
  return mean(data.value);
});

// Async component helper
const AsyncStats = defineSciMathComponent({
  props: ['data'],
  async setup(props) {
    const stats = await computeStats(props.data);
    return { stats };
  }
});
```

### 3.3 Node.js Improvements

- [ ] Native WASI support (no browser polyfills)
- [ ] Worker threads integration
- [ ] Stream processing for large files
- [ ] Buffer zero-copy optimizations

```typescript
// Node.js optimized path
import { createSciMath } from '@sci-math/node';

const sci = await createSciMath({
  workers: 4,
  memoryLimit: '1gb'
});

// Stream processing
import { pipeline } from 'stream/promises';
import { createFFTStream } from '@sci-math/node/streams';

await pipeline(
  fs.createReadStream('large-data.bin'),
  createFFTStream({ windowSize: 4096, overlap: 0.5 }),
  fs.createWriteStream('spectrum.bin')
);
```

### 3.4 CDN Distribution

```html
<!-- UMD bundle for quick prototyping -->
<script src="https://cdn.jsdelivr.net/npm/sci-math-wasm@latest/dist/sci-math.umd.js"></script>
<script>
  SciMath.init().then(() => {
    const avg = SciMath.mean([1, 2, 3, 4, 5]);
    console.log('Mean:', avg);
  });
</script>

<!-- ES Module from CDN -->
<script type="module">
  import { mean, fft } from 'https://esm.sh/sci-math-wasm';
  const avg = await mean([1, 2, 3, 4, 5]);
</script>
```

### 3.5 Web Worker Bundle

```typescript
// Dedicated worker bundle for heavy computations
import { createWorkerMath } from 'sci-math-wasm/worker';

const worker = await createWorkerMath();

// Non-blocking heavy computations
const result = await worker.run('fft', largeData);

// Batch operations in worker
const results = await worker.batch([
  { op: 'mean', args: [data1] },
  { op: 'variance', args: [data2] },
  { op: 'fft', args: [data3] }
]);

// Transfer ownership (zero-copy)
const spectrum = await worker.run('fft', data, { transfer: true });
```

---

## Phase 4: Advanced Features (Q4 2026)

### 4.1 GPU Acceleration (WebGPU)

```typescript
import { enableGPU, gpuMatMul } from 'sci-math-wasm/gpu';

await enableGPU(); // Auto-detect WebGPU support

// GPU-accelerated matrix multiplication
const result = await gpuMatMul(largeMatrixA, largeMatrixB);

// Hybrid execution strategy
configure({
  execution: {
    matmul: { threshold: 256, prefer: 'gpu' },  // Use GPU for matrices > 256x256
    fft: { threshold: 8192, prefer: 'gpu' },    // Use GPU for FFT > 8192 points
    stats: { prefer: 'wasm' }                    // Always use WASM for stats
  }
});
```

### 4.2 Machine Learning Primitives

```typescript
import { 
  linearLayer, sigmoid, relu, softmax,
  batchNorm, dropout, conv2d
} from 'sci-math-wasm/ml';

// Neural network building blocks
const hidden = relu(linearLayer(input, weights1, bias1));
const output = softmax(linearLayer(hidden, weights2, bias2));

// Automatic differentiation (future)
import { autograd } from 'sci-math-wasm/autograd';

const loss = autograd((x, y) => {
  const pred = model(x);
  return mse(pred, y);
});

const gradients = loss.backward(input, target);
```

### 4.3 Scientific File Formats

- [ ] HDF5 reading (via wasm port)
- [ ] NetCDF support
- [ ] MATLAB .mat files
- [ ] Numpy .npy/.npz files
- [ ] Parquet files
- [ ] Arrow IPC format

```typescript
import { readHDF5, readNetCDF, readNPY } from 'sci-math-wasm/io';

const h5 = await readHDF5(file);
const dataset = h5.get('/measurements/voltage');

const nc = await readNetCDF(file);
const temperature = nc.variable('temp').slice([0, 0], [100, 100]);

const array = await readNPY(file); // Returns Float64Array
```

### 4.4 Symbolic Mathematics (Future Vision)

```typescript
import { symbolic as S } from 'sci-math-wasm/symbolic';

const x = S.symbol('x');
const expr = S.sin(x) ** 2 + S.cos(x) ** 2;

console.log(S.simplify(expr)); // "1"
console.log(S.diff(S.sin(x), x)); // "cos(x)"
console.log(S.integrate(S.exp(x), x)); // "exp(x)"

// Compile to efficient WASM
const f = S.compile(S.sin(x) * S.cos(x));
const result = f(0.5); // Optimized evaluation
```

---

## Technical Debt & Improvements

### Code Quality

- [ ] **Consistent Error Handling:** Replace `unwrap()` with proper `Result` types
- [ ] **Remove `unsafe` where possible:** Audit all unsafe blocks
- [ ] **Better naming conventions:** Align Rust and JS names
- [ ] **Module organization:** Split large files (analysis.rs is 352 lines)

### Testing

- [ ] **Property-based testing:** Add fuzzing with `arbitrary`
- [ ] **Cross-browser testing:** Playwright integration
- [ ] **Performance regression tests:** Automated benchmarks in CI
- [ ] **Numerical accuracy tests:** Compare with reference implementations (NumPy, SciPy)

### Build System

- [ ] **Optimize WASM size:** Currently includes debug symbols
- [ ] **Tree-shaking support:** Allow importing individual modules
- [ ] **Source maps:** Better debugging in browsers
- [ ] **Multi-target builds:** Separate bundles for web/node/deno

### Documentation

- [ ] **Interactive examples:** Runnable code in docs
- [ ] **Algorithm explanations:** Add mathematical background
- [ ] **Migration guide:** From NumPy/SciPy patterns
- [ ] **Performance guide:** When to use WASM vs JS
- [ ] **Video tutorials:** Getting started, common patterns

---

## Architecture Decisions

### Decision 1: Hybrid Execution Strategy

**Context:** Some operations are faster in pure JS due to WASM boundary overhead.

**Decision:** Implement automatic selection based on input size and operation type.

```typescript
// Internal dispatcher
function dispatchMean(data: NumericArray): number {
  if (data.length < 1000) {
    return jsMean(data); // JS is faster for small arrays
  }
  return wasmMean(data); // WASM wins for large arrays
}
```

### Decision 2: Memory Management

**Context:** Frequent allocations hurt performance.

**Decision:** Use memory pools with configurable lifetime.

- **Short-lived:** Auto-release after operation
- **Session-lived:** Release on `dispose()`
- **Manual:** User controls lifetime

### Decision 3: Thread Pool

**Context:** SharedArrayBuffer requires COOP/COEP headers.

**Decision:** Auto-detect and gracefully degrade.

```typescript
// Detection flow
async function initThreads() {
  if (!crossOriginIsolated) {
    console.warn('sci-math-wasm: Cross-origin isolation not enabled. Running single-threaded.');
    return 1;
  }
  return navigator.hardwareConcurrency ?? 4;
}
```

### Decision 4: Bundling Strategy

**Context:** Different environments have different needs.

**Decision:** Multiple entry points:

```
sci-math-wasm/
â”œâ”€â”€ index.js          # Auto-detecting entry
â”œâ”€â”€ web.js            # Browser-optimized
â”œâ”€â”€ node.js           # Node-optimized
â”œâ”€â”€ worker.js         # Web Worker bundle
â””â”€â”€ lite.js           # Core functions only (~50KB)
```

---

## Milestones & Success Metrics

### Q1 2026
- [ ] Zero-config initialization working
- [ ] 90% TypeScript type coverage
- [ ] < 100ms cold start time
- [ ] 50+ stars on GitHub

### Q2 2026
- [ ] SIMD optimization for top 5 functions
- [ ] DataFrame API beta
- [ ] Memory pool system
- [ ] < 50KB core bundle size

### Q3 2026
- [ ] React & Vue packages published
- [ ] Node.js performance parity with native
- [ ] CDN distribution
- [ ] 500+ weekly npm downloads

### Q4 2026
- [ ] GPU acceleration beta
- [ ] HDF5/NetCDF support
- [ ] ML primitives
- [ ] 1000+ weekly npm downloads

---

## Contributing

We welcome contributions! Priority areas:

1. **High Impact:** SIMD optimizations, DataFrame API
2. **Medium Impact:** Framework integrations, file format support
3. **Good First Issues:** TypeScript improvements, documentation

See [CONTRIBUTING.md](./CONTRIBUTING.md) for guidelines.

---

## References

- [WebAssembly SIMD](https://v8.dev/features/simd)
- [wasm-bindgen-rayon](https://github.com/RReverser/wasm-bindgen-rayon)
- [Polars](https://github.com/pola-rs/polars) (DataFrame inspiration)
- [NumPy](https://numpy.org/) (API inspiration)
- [SciPy](https://scipy.org/) (Algorithm reference)

---

*Last Updated: February 2026*
*Version: 1.0.0*
